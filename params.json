{"name":"Discovery Agent","tagline":"Reactive Consul client written in java 8","body":"# discovery-agent\r\n\r\nReactive [Consul](http://www.consul.io) client written in java 8\r\n\r\n##Setup\r\nmaven\r\n```xml\r\n\r\n  <dependency>\r\n    <groupId>com.totango</groupId>\r\n    <artifactId>discovery-agent</artifactId>\r\n    <version>0.2.0</version>\r\n  </dependency>\r\n\r\n```\r\ngradle\r\n```\r\n'com.totango:discovery-agent:0.2.0'\r\n\r\n```\r\n\r\n## ConsulClient\r\nConsulClient is a HTTP client for [Consul](http://www.consul.io). You can either choose to work directly with ConsulClient or you can use the ServiceDiscovery or RoundRobinLoadBalancer which are targeted to more specific use cases. We suggest you read the whole README to fully understand which class to use when.  \r\n\r\nBy default ConsulClient connects to Consul agent on localhost, port 8500 and uses 5min for update blocking calls.\r\n\r\n```java\r\n\r\nConsulClientFactory consulClientFactory = new ConsulClientFactory();\r\nConsulClient consulClient = consulClientFactory.client();\r\n\r\n```\r\n\r\nYou can also provide a different host, port or wait timeout for consul blocking calls.\r\n\r\n```java\r\n\r\nConsulClientFactory consulClientFactory = new ConsulClientFactory();\r\nConsulClient consulClient = consulClientFactory\r\n  .host(server.getHostName())\r\n  .port(server.getPort())\r\n  .waitTimeInSec(waitTimeInSec)\r\n  .client();\r\n\t\r\n```\r\n\r\nGet a list of healthy services\r\n\r\n```java\r\n\r\nServiceRequest serviceRequest = Service.request()\r\n  .forService(serviceName)\r\n  .build();\r\n\t\t\t\r\nOptional<ServiceGroup> response = consulClient.discoverService(serviceRequest);\r\n\t\r\n```\r\n\r\nYou can then use the response to make calls to the service. In this example we use OkHttp to make an HTTP call to the service.\r\n\r\n```java\r\n\r\nif (response.isPresent() && response.get().size() > 0) {\r\n\t\r\n\tList<Service> services = response.get().getServices();\r\n\t\t\r\n\t// choose one from the list\r\n\tService service = services.get(0);\r\n\t\t\r\n\tString url = String.format(\"http://%s:%d\", service.getAddress(), service.getServicePort());\r\n\tRequest request = new Request.Builder().url(url).build();\r\n\tResponse response = httpClient.newCall(request).execute();\r\n\t...\r\n} else {\r\n\tlogger.log(\"Failed to discover a healthy \" + serviceName);\r\n}\r\n\r\n```\r\n\r\nYou can get a healthy service with name and tag.\r\n\r\n```java\r\n\r\nString tag = \"master\";\r\n\t\r\nServiceRequest serviceRequest = Service.request()\r\n\t.forService(serviceName)\r\n\t.withTag(tag)\r\n\t.build();\r\n\t\t\r\n```\r\n\r\nYou can also listen for Consul service updates using the index of the last results. The call block until there is an update or the provided waitTimeoutInMs that was passed to the ConsulClientFactory was passed.  \r\n\r\n```java\r\n\r\nString tag = \"master\";\r\n\t\r\nServiceRequest serviceRequest = Service.request()\r\n\t.forService(serviceName)\r\n\t.lastUpdateIndex(index)\r\n\t.build();\r\n\t\t\r\n```\r\n\r\nConsulClient can also call the Consul key-value api.\r\n \r\n ```java\r\n\r\nOptional<Value> result = consulClient.keyValue(key);\r\n\t\r\n```\r\n\r\nTo listen for key-value updates you need to provide the index of the last results. The call block until there is an update or the provided waitTimeoutInMs that was passed to the ConsulClientFactory was passed.\r\n\r\n ```java\r\n\r\nOptional<Value> result = consulClient.keyValue(key, index);\r\n\t\r\n```\r\n\r\n## DiscoveryService\r\nListen for updates is very useful but requires some work. This is why we have the DiscoveryService class.\r\nDiscoveryService is a class that helps you register for service updates.\r\nWhen you create a DiscoveryService instance you need to provide a ConsulClient, number of retries if the calls to the Consul Agent fail and function which will provide the delay in milliseconds between the retries.  \r\n\r\nHere is an example of a DiscoveryService with 10 retries. The retry function is a 1 - 10 series.\r\n \r\n```java\r\n\r\nDiscoveryService discoveryService = new DiscoveryService(consulClient, 10, i -> i);\r\n\r\n```\r\n\r\nThe retry in this example is the number of retry to the power of 3. In case of failure \r\n\r\n```java\r\n\r\nDiscoveryService discoveryService = new DiscoveryService(consulClient, Integer.MAX_VALUE, i -> (int)Math.pow(i, 3), TimeUnit.MILLISECONDS);\r\n\r\n```\r\n\r\nTo subscribe for updates from Consul you need to provide the service name and an Action to be performed when there is an update.\r\nThe DiscoveryService will continue to listen for updates as long as there is subscription for updates.  \r\nIn case of an error getting an update from Consul, DiscoveryService will retry the call up to the given retry with a wait time that is calculated using the delay function. This is very handy in order to provide exponential back off in case of failures. If the max retry is reached or the call succeed, as long as there is subscription, it will continue listen for updates. In both cases the retry counter will be reset.  \r\n\r\n```java\r\n\r\nSubscription subscribe = discoveryService.subscribe(\"web-server\", services -> {\r\n  // do something with the returned List<Service>\r\n});\r\n\r\n```\r\n\r\nIf you want to take an action on errors you can provide an additional Action.\r\n\r\n```java\r\n\r\nSubscription subscribe = discoveryService.subscribe(\"web-server\", services -> {\r\n     // do something with the List<Service>\r\n\t},\r\n\tthrowable -> {\r\n\t\t// do something with the Throwable\r\n\t});\r\n  \r\n```\r\n\r\nTo unsubscribe from updates just call\r\n\r\n```java\r\nsubscribe.unsubscribe();\r\n```\r\n\r\nDiscoveryService works with RxJava so you can subscribe to update using Subscriber, Observer and Action. \r\n\r\n## RoundRobinLoadBalancer\r\nOne of the things you can do when Consul return a list of instances that provides the same service is to call all of the instances in a round robin and this way to spread the load between them.\r\nFor this functionality we have The RoundRobinLoadBalancer.\r\nThe RoundRobinLoadBalancer uses a DiscoveryService in order to always know the most up to date service list. So when it is asked for the next endpoint it will provide a healthy one. To tell the balancer to start listening for updates you need to call the init() method.\r\n \r\n```java\r\n\r\nRoundRobinLoadBalancer balancer = new RoundRobinLoadBalancer(discoveryService, serviceName);\r\nbalancer.init();\r\n\r\n```\r\n\r\nTo use the LoadBalancer you need to call the withNextEndpoint() method with a function that gets host and port. withNextEndpoint() is a generic method that can return any kind of Object you need to return in your case.\r\n\r\n```java\r\n\t\r\nbalancer.withNextEndpoint((host, port) -> {\r\n\tString url = String.format(\"http://%s:%d\", host, port);\r\n\tRequest request = new Request.Builder().url(url).build();\r\n\tResponse response = httpClient.newCall(request).execute();\r\n\t...\r\n\t\t\r\n\treturn result;\r\n});\r\n\r\n```\r\n\r\n\r\n\r\n## License\r\n\r\n```\r\n\r\n   Copyright 2015 Totango, Inc\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}